;
; USRROM	TEMPLATE FOR A CUSTOM USER ROM
;

ROMSIZE		.EQU		512
RAMSIZE		.EQU	512		; SIZE OF RAM IN KB (MUST MATCH YOUR HARDWARE!!!)

BID_ROM0	.EQU	$00
BID_RAM0	.EQU	$80
BID_ROMN	.EQU	(BID_ROM0 + ((ROMSIZE / 32) - 1))
BID_RAMN	.EQU	(BID_RAM0 + ((RAMSIZE / 32) - 1))
BID_BOOT	.EQU	BID_ROM0	; BOOT BANK
BID_IMG0	.EQU	BID_ROM0 + 1	; ROM LOADER AND FIRST IMAGES BANK
BID_IMG1	.EQU	BID_ROM0 + 2	; SECOND IMAGES BANK
BID_FSFAT	.EQU	BID_ROM0 + 3	; FAT FILESYSTEM DRIVER BANK
BID_ROMD0	.EQU	BID_ROM0 + 4	; FIRST ROM DRIVE BANK
BID_ROMDN	.EQU	BID_ROMN	; LAST ROM DRIVE BANK
BID_RAMD0	.EQU	BID_RAM0	; FIRST RAM DRIVE BANK
BID_RAMDN	.EQU	BID_RAMN - 4	; LAST RAM DRIVE BANK
BID_AUX		.EQU	BID_RAMN - 3	; AUX BANK (BPBIOS, ETC.)
BID_BIOS	.EQU	BID_RAMN - 2	; BIOS BANK
BID_USR		.EQU	BID_RAMN - 1	; USER BANK (CP/M TPA, ETC.)
BID_COM		.EQU	BID_RAMN	; COMMON BANK, UPPER 32K

	.ECHO	"ROMIDS from "
	.ECHO	BID_ROM0
	.ECHO	" to "
	.ECHO	BID_ROMDN
	.ECHO	"\r\n"

	.ECHO	"RAMIDS from "
	.ECHO	BID_RAM0
	.ECHO	" to "
	.ECHO	BID_COM
	.ECHO	"\r\n"

BF_SYSGET_CIOCNT	.EQU	$00	; GET CHAR UNIT COUNT
BF_SYSGET_CIOFN		.EQU	$01	; GET CIO UNIT FN/DATA ADR
BF_SYSGET_DIOCNT	.EQU	$10	; GET DISK UNIT COUNT
BF_SYSGET_DIOFN		.EQU	$11	; GET DIO UNIT FN/DATA ADR
BF_SYSGET_RTCCNT	.EQU	$20	; GET RTC UNIT COUNT
BF_SYSGET_VDACNT	.EQU	$40	; GET VDA UNIT COUNT
BF_SYSGET_VDAFN		.EQU	$41	; GET VDA UNIT FN/DATA ADR
BF_SYSGET_SNDCNT	.EQU	$50	; GET VDA UNIT COUNT
BF_SYSGET_SNDFN		.EQU	$51	; GET SND UNIT FN/DATA ADR
BF_SYSGET_TIMER		.EQU	$D0	; GET CURRENT TIMER VALUE
BF_SYSGET_SECS		.EQU	$D1	; GET CURRENT SECONDS VALUE
BF_SYSGET_BOOTINFO	.EQU	$E0	; GET BOOT INFORMATION
BF_SYSGET_CPUINFO	.EQU	$F0	; GET CPU INFORMATION
BF_SYSGET_MEMINFO	.EQU	$F1	; GET MEMORY CAPACTITY INFO
BF_SYSGET_BNKINFO	.EQU	$F2	; GET BANK ASSIGNMENT INFO
;
BF_SYSSET_TIMER		.EQU	$D0	; SET TIMER VALUE
BF_SYSSET_SECS		.EQU	$D1	; SET SECONDS VALUE
BF_SYSSET_BOOTINFO	.EQU	$E0	; SET BOOT INFORMATION

BF_SYS		.EQU	$F0
BF_SYSRESET	.EQU	BF_SYS + 0	; SOFT RESET HBIOS
BF_SYSVER	.EQU	BF_SYS + 1	; GET HBIOS VERSION
BF_SYSSETBNK	.EQU	BF_SYS + 2	; SET CURRENT BANK
BF_SYSGETBNK	.EQU	BF_SYS + 3	; GET CURRENT BANK
BF_SYSSETCPY	.EQU	BF_SYS + 4	; BANK MEMORY COPY SETUP
BF_SYSBNKCPY	.EQU	BF_SYS + 5	; BANK MEMORY COPY
BF_SYSALLOC	.EQU	BF_SYS + 6	; ALLOC HBIOS HEAP MEMORY
BF_SYSFREE	.EQU	BF_SYS + 7	; FREE HBIOS HEAP MEMORY
BF_SYSGET	.EQU	BF_SYS + 8	; GET HBIOS INFO
BF_SYSSET	.EQU	BF_SYS + 9	; SET HBIOS PARAMETERS
BF_SYSPEEK	.EQU	BF_SYS + 10	; GET A BYTE VALUE FROM ALT BANK
BF_SYSPOKE	.EQU	BF_SYS + 11	; SET A BYTE VALUE IN ALT BANK
BF_SYSINT	.EQU	BF_SYS + 12	; MANAGE INTERRUPT VECTORS


CR	.EQU    0DH
LF	.EQU    0AH

BID_ROMEX	.EQU	$10

bnkid	.equ	BID_ROMEX;BID_USR
;
	.ORG    $100

	LD	HL, (6)
	LD	SP, HL

	ld	a, bnkid


	BIT	7,A			; BIT 7 SET REQUESTS RAM PAGE
	JR	Z, HBX_ROMS		; NOT SET, SELECT ROM PAGE
HBX_RAM:
	RES	7,A			; RAM PAGE REQUESTED: CLEAR ROM BIT
	ADD	A,16			; ADD 16 X 32K - RAM STARTS FROM 512K
	RLCA				; TIMES 2 - GET 16K PAGE INSTEAD OF 32K
	SET	6, A
	RES	5, A
	JR	HBX_GO
;
HBX_ROMS:
	BIT	4,A
	JR	Z, HBX_ROM1

	RLCA
	JR	HBX_GO

HBX_ROM1:
	RLCA				; TIMES 2 - GET 16K PAGE INSTEAD OF 32K


HBX_GO:
	call	PRTHEX


	; ld	hl, RA_ENT
	; call	PRTHEX_HL

	;LOAD FIRST 256 BYTES FROM EXTERNAL ROM?
	ld	e,bnkid			;  FIRST PAGE IN EXTERNAL ROM
	ld	d,BID_USR		; dest is user bank
	ld	hl,256		; HL := image size
	ld	b,BF_SYSSETCPY		; HBIOS func: setup bank copy
	rst	08			; do it

	ld	de,STORE		; DE := run dest adr
	ld	hl,0		; HL := image source adr
	ld	b,BF_SYSBNKCPY		; HBIOS func: bank copy
	rst	08

	CALL	PRTSTRD
	.DB	"DRIVER DATA: ",0

	call	CRLF

	LD	B, 0
	ld	c, 16
	LD	HL, STORE

LOOP2:
	LD	A, (HL)
	CALL	PRTHEX

	CALL	PRTSTRD
	.DB	" ", 0

	dec	c
	jr	nz, skip1

	ld	c, 16
	call	CRLF

skip1:
	INC	HL
	DJNZ	LOOP2

	JP	0	;


	; CHECK FOR EXT ROM
	; IF NOT THERE - LOAD CPM FROM INTERANAL ROM (romload)
	; ELSE LOAD EXT ROM????

BITFLIP:
	BIT	5, A
	RET	Z
	SET	6, A
	RES	5, A
	RET

;
; OUTPUT CHARACTER IN A TO CONSOLE DEVICE
;
COUT:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	B,01H
	LD	C,0
	LD	E,A
	RST	08
	POP	DE
	POP	BC
	POP	AF
	RET
;
; OUTPUT CHARACTER IN A TO CONSOLE DEVICE
;
COUTE:	PUSH	AF
	LD	A,E
	CALL	COUT
	POP	AF
	RET
;
; WAIT FOR A CHARACTER FROM THE CONSOLE DEVICE AND RETURN IT IN A
;
CIN:	PUSH	BC
	LD	B,00H
	LD	C,00H
	RST	08
	LD	A,E
	POP	BC
	RET

;===============================================================================
; PRINT CHARACTER IN A WITHOUT DESTROYING ANY REGISTERS

;===============================================================================
; PRINT A STRING DIRECT: REFERENCED BY POINTER AT TOP OF STACK
; STRING MUST BE TERMINATED BY '$'
; USAGE:
;   CALL PRTSTR
;   .DB  "HELLO$"

PRTSTRD:
	EX	(SP), HL
	push	af
	CALL	PRTSTRZ
	pop	af
	EX	(SP), HL
	RET


;===============================================================================
; PRINT A $ TERMINATED STRING AT (HL) WITHOUT DESTROYING ANY REGISTERS
PRTSTRZ:
	LD	A, (HL)			; GET NEXT CHAR
	INC	HL
	CP	0
	RET	Z
	CALL	COUT
	JR	PRTSTRZ

PRTHEX_DE:
	PUSH	HL
	EX	DE, HL
	CALL	PRTHEX_HL
	POP	HL
	RET

PRTHEX_HL:
	LD	A, H
	CALL	PRTHEX
	LD	A, L
	CALL	PRTHEX
	RET
;===============================================================================
; PRINT THE VALUE IN A IN HEX WITHOUT DESTROYING ANY REGISTERS

PRTHEX:
	PUSH	AF			; SAVE AF
	PUSH	DE			; SAVE DE
	CALL	HEXASCII		; CONVERT VALUE IN A TO HEX CHARS IN DE
	LD	A, D			; GET THE HIGH ORDER HEX CHAR
	CALL	COUT			; PRINT IT
	LD	A, E			; GET THE LOW ORDER HEX CHAR
	CALL	COUT			; PRINT IT
	POP	DE			; RESTORE DE
	POP	AF			; RESTORE AF
	RET				; DONE

;===============================================================================
; CONVERT BINARY VALUE IN A TO ASCII HEX CHARACTERS IN DE

HEXASCII:
	LD	D, A			; SAVE A IN D
	CALL	HEXCONV			; CONVERT LOW NIBBLE OF A TO HEX
	LD	E, A			; SAVE IT IN E
	LD	A, D			; GET ORIGINAL VALUE BACK
	RLCA				; ROTATE HIGH ORDER NIBBLE TO LOW BITS
	RLCA
	RLCA
	RLCA
	CALL	HEXCONV			; CONVERT NIBBLE
	LD	D, A			; SAVE IT IN D
	RET				; DONE

;===============================================================================
; CONVERT LOW NIBBLE OF A TO ASCII HEX

HEXCONV:
	AND	$0F	     		; LOW NIBBLE ONLY
	ADD	A, $90
	DAA
	ADC	A, $40
	DAA
	RET

;===============================================================================
; START A NEW LINE

CRLF:
	LD	A, 13			; <CR>
	CALL	COUT			; PRINT IT
	LD	A, 10			; <LF>
	JR	COUT			; PRINT IT

STORE:	.FILL	256, 0

	.END
