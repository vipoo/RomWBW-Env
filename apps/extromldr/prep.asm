;
; USRROM	TEMPLATE FOR A CUSTOM USER ROM
;

ROMSIZE		.EQU	512
RAMSIZE		.EQU	512		; SIZE OF RAM IN KB (MUST MATCH YOUR HARDWARE!!!)
BID_ROM0	.EQU	$00
BID_RAM0	.EQU	$80
BID_ROMN	.EQU	(BID_ROM0 + ((ROMSIZE / 32) - 1))
BID_RAMN	.EQU	(BID_RAM0 + ((RAMSIZE / 32) - 1))
BID_BOOT	.EQU	BID_ROM0	; BOOT BANK
BID_IMG0	.EQU	BID_ROM0 + 1	; ROM LOADER AND FIRST IMAGES BANK
BID_IMG1	.EQU	BID_ROM0 + 2	; SECOND IMAGES BANK
BID_FSFAT	.EQU	BID_ROM0 + 3	; FAT FILESYSTEM DRIVER BANK
BID_ROMD0	.EQU	BID_ROM0 + 4	; FIRST ROM DRIVE BANK
BID_ROMDN	.EQU	BID_ROMN	; LAST ROM DRIVE BANK
BID_RAMD0	.EQU	BID_RAM0	; FIRST RAM DRIVE BANK
BID_RAMDN	.EQU	BID_RAMN - 4	; LAST RAM DRIVE BANK
BID_AUX		.EQU	BID_RAMN - 3	; AUX BANK (BPBIOS, ETC.)
BID_BIOS	.EQU	BID_RAMN - 2	; BIOS BANK
BID_USR		.EQU	BID_RAMN - 1	; USER BANK (CP/M TPA, ETC.)
BID_COM		.EQU	BID_RAMN	; COMMON BANK, UPPER 32K


BID_ROMEX0	.EQU	$20		;$00000 to $07FFF
BID_ROMEX1	.EQU	BID_ROMEX0 + 1	;$08000 to $0FFFF
BID_ROMEX2	.EQU	BID_ROMEX0 + 2	;$10000 to $17FFF
BID_ROMEX3	.EQU	BID_ROMEX0 + 3	;$18000 to $1FFFF
BID_ROMEX4	.EQU	BID_ROMEX0 + 4

LOADER_BANK	.EQU	BID_ROMEX0
LOADER_RELOC	.EQU	$4000
LOADER_SIZE	.EQU	$1000	; LOADER - 4k ($00000 to 00FFF)

BIOS_BANK	.EQU	BID_ROMEX0
BIOS_LOC	.EQU	0 + LOADER_SIZE		; BIOS   AT $01000 TO $02FFF (8k)
BIOS_SIZE	.EQU	$2000

DONKEY_BANK	.EQU	BID_ROMEX0		; CONTINUES ON INTO BID_ROMEX1
DONKEY_LOC	.EQU	BIOS_LOC + BIOS_SIZE	; DONKEY AT $03000 TO $09000 (24k)
DONKEY_SIZE	.EQU	$6000

#include "../../RomWBW/Source/HBIOS/hbios.inc"

CR	.EQU    0DH
LF	.EQU    0AH
;
	.ORG	$100			; CPM ENTRY POINT

	LD	HL, (6)			; SET STACK TO TOPMEM (UNDER CPM)
	LD	SP, HL

	LD	B, $48
	LD	C, 0
	LD	E, 65
	LD	D, 0
	RST	08

	LD	B, $48
	LD	C, 0
	LD	E, 66
	LD	D, 0
	RST	08

	LD	B, $48
	LD	C, 0
	LD	E, 67
	LD	D, 0
	RST	08

	; TEST FOR ROM
	; COPY FIRST 4 BYTES OF START OF EXTERNAL ROM
	; TO STORE
	LD	E, BID_ROMEX0		; 1ST BANK OF EXTERNAL ROM
	LD	D, BID_USR		; DEST IS USER BANK
	LD	HL, 256			; HL := IMAGE SIZE
	LD	B, BF_SYSSETCPY		; HBIOS FUNC: SETUP BANK COPY
	RST	08

	LD	DE, STORE		; DE := RUN DEST ADR
	LD	HL, 0			; HL := IMAGE SOURCE ADR
	LD	B, BF_SYSBNKCPY		; HBIOS FUNC: BANK COPY
	RST	08


	; ROM FIRST 4 BYTES SHOULD BE 10, 12, 13, 14
	LD	A, (STORE)
	CP	$10
	JP	NZ, NOROM

	LD	A, (STORE+1)
	CP	$12
	JP	NZ, NOROM

	LD	A, (STORE+2)
	CP	$13
	JP	NZ, NOROM

	LD	A, (STORE+3)
	CP	$14
	JP	NZ, NOROM

LISTLOOP:
	LD	HL, STORE + 6	; FIRST GAME STRING POINTER
	LD	E, (HL)
	INC	HL
	LD	D, (HL)

	LD	A, E
	OR	D
	JR	Z, LISTDONE

	CALL	PRTSTRDE

	INC	HL
	INC	HL
	INC	HL

	JR	LISTLOOP

LISTDONE:
	JP	0

	; READ ROM HEADER
	; FIND ADDR OF FIRST APP

#IF 0
	LD	E, BID_ROMEX0		; FIRST PAGE IN EXTERNAL ROM
	LD	D, BID_USR		; DEST IS USER BANK
	LD	HL, (STORE+6)
	LD	B, BF_SYSSETCPY		; HBIOS FUNC: SETUP BANK COPY
	RST	08

	LD	DE, (STORE+4)		; DE := RUN DEST ADR
	LD	HL, 8			; HL := IMAGE SOURCE ADR
	LD	B, BF_SYSBNKCPY		; HBIOS FUNC: BANK COPY
	RST	08

	LD	IX, (STORE+4)
 	JP	(IX)

#else

#if 1
MPGSEL_0	.EQU	$78		; Z2 MEM MGR BANK 0 PAGE SELECT REG (WRITE ONLY)
MPGSEL_1	.EQU	$79		; Z2 MEM MGR BANK 1 PAGE SELECT REG (WRITE ONLY)
MPGSEL_2	.EQU	$7A		; Z2 MEM MGR BANK 2 PAGE SELECT REG (WRITE ONLY)
MPGSEL_3	.EQU	$7B		; Z2 MEM MGR BANK 3 PAGE SELECT REG (WRITE ONLY)

	JP	$4100

	.ORG	$4100





	; SWITCH EXTROM BANK 0 INTO ADDR $0000
	; SWITCH EXTROM BANK 1 INTO ADDR $8000
	; SWITCH EXTROM BANK 2 INTO ADDR $C000

	LD	A, BID_ROMEX0 * 2	; TIMES 2 - GET 16K PAGE INSTEAD OF 32K
	OUT	(MPGSEL_0),A		; BANK_0: 0K - 16K

	LD	A, BID_ROMEX1 * 2	; TIMES 2 - GET 16K PAGE INSTEAD OF 32K
	OUT	(MPGSEL_2),A		; BANK_2: 32K - 48K
	INC	A			;
	OUT	(MPGSEL_3),A		; BANK_1: 48K - 64K


TMS_CMDREG	.EQU	$BF		; READ STATUS / WRITE REG SEL
TMSCTRL1:       .EQU   1               ; CONTROL BITS

	; ENSURE TMS IS NOT RAISING INTERRUPTS
	; SO WHEN NMI IS SELECTED NO INTERRUPTS WILL BE RAISED
	; UNTIL BIOS IS LOADED
	LD	A, $50			; DISABLE INT BIT
	OUT	(TMS_CMDREG), A		; WRITE IT
	EX	(SP), HL		; WAIT A BIT FOR TMS
	EX	(SP), HL
	LD	A, $81			; SELECT REGISTER 1 OF TMS
	OUT	(TMS_CMDREG), A		; SELECT THE DESIRED REGISTER

	DI

	LD	A, $FF		; DROP CLOCK TO 3.6864
	OUT	(15), A

	LD	A, $FF
	OUT	(14), A		; SWITCH TO NMI

	JP	0

#else
	JP	$4000

	.ORG	$4000

	CALL	PRTSTRD
	.DB	"LOADING BIOS FROM ROM....",0
	call	CRLF

	; COPY COLECO BIOS TO $0100 IN LOWER RAM
	LD	E, BID_ROMEX0		; FIRST PAGE IN EXTERNAL ROM
	LD	D, BID_USR		; DEST IS USER BANK
	LD	HL, BIOS_SIZE
	LD      B, BF_SYSSETCPY		; HBIOS FUNC: SETUP BANK COPY
	RST     08
	LD      DE, $0100		; STORE BIOS AT 100 - TO AVOID CORRUPTING CPM BLOCKS/FCB ETC.
	LD      HL, BIOS_LOC		; HL := IMAGE SOURCE ADR
	LD      B, BF_SYSBNKCPY		; HBIOS FUNC: BANK COPY
	RST     08

#IF 0

	CALL	PRTSTRD
	.DB	"START OF BIOS: ",0
	call	CRLF
	LD	HL, $0100
	CALL	dumpdat
#ENDIF

	; COPY GAME IMAGE TO BELOW HBIOS
	LD	E, BID_ROMEX0		; FIRST PAGE IN EXTERNAL ROM
	LD	D, BID_USR		; DEST IS USER BANK
	LD	HL, $5000		; FIRST SECTION IS IN BANK 0
	LD	B, BF_SYSSETCPY		; HBIOS FUNC: SETUP BANK COPY
	RST	08
	LD	DE, STORE		; TEMP STORE GAME ROM AT END OF US
	LD	HL, DONKEY_LOC		; GAME ROM ADDR
	LD	B, BF_SYSBNKCPY		; HBIOS FUNC: BANK COPY
	RST	08
	LD	E, BID_ROMEX1		; SECOND PAGE IN EXTERNAL ROM
	LD	D, BID_USR		; DEST IS USER BANK
	LD	HL, DONKEY_SIZE - $5000	; REMAINING BLOCK IS IN BANK 1
	LD	B, BF_SYSSETCPY		; HBIOS FUNC: SETUP BANK COPY
	RST	08
	LD	DE, STORE + $5000	; CONTINUE FROM PREVIOUS BLOCK COPY
	LD	HL, 0			; AT BEGINING OF BANK 2
	LD	B, BF_SYSBNKCPY         ; HBIOS FUNC: BANK COPY
	RST	08

#IF 0
	CALL	PRTSTRD
	.DB	"START OF GAME: ",0
	call	CRLF
	LD	HL, STORE
	CALL	dumpdat

	CALL	PRTSTRD
	.DB	"GAME AT +4F00: ",0
	call	CRLF
	LD	HL, STORE + $4F00
	CALL	dumpdat

	CALL	PRTSTRD
	.DB	"GAME AT +5000: ",0
	call	CRLF
	LD	HL, STORE + $5000
	CALL	dumpdat


	CALL	PRTSTRD
	.DB	"GAME AT +5F00: ",0
	call	CRLF
	LD	HL, STORE + $5F00
	CALL	dumpdat

#ENDIF

TMS_CMDREG	.EQU	$BF		; READ STATUS / WRITE REG SEL
TMSCTRL1:       .EQU   1               ; CONTROL BITS

	; ENSURE TMS IS NOT RAISING INTERRUPTS
	; SO WHEN NMI IS SELECTED NO INTERRUPTS WILL BE RAISED
	; UNTIL BIOS IS LOADED
	LD	A, $50			; DISABLE INT BIT
	OUT	(TMS_CMDREG), A		; WRITE IT
	EX	(SP), HL		; WAIT A BIT FOR TMS
	EX	(SP), HL
	LD	A, $81			; SELECT REGISTER 1 OF TMS
	OUT	(TMS_CMDREG), A		; SELECT THE DESIRED REGISTER

	DI

	; SHIFT BIOS FROM $0100 TO 0000
	LD	HL, $0100
	LD	DE, $0000
	LD	BC, BIOS_SIZE		; BIOS SIZE
	LDIR

	; SHIFT GAME ROM FROM STORE TO UPPER MEM
	LD	BC, DONKEY_SIZE
	LD	DE, $8000 + DONKEY_SIZE	- 1	; DEST AT $8000+GAMESIZ-1
	LD	HL, STORE + DONKEY_SIZE - 1	; SOURCE AT STORE+GAMESIZ-1
	LDDR					; SHIFT TO UPPER RAM

	LD	A, $FF		; DROP CLOCK TO 3.6864
	OUT	(15), A

	LD	A, $FF
	OUT	(14), A		; SWITCH TO NMI

	JP	0
#endif
#endif


; 	CALL	PRTSTRD
; 	.DB	CR, LF, 0


; 	CALL	PRTSTRD
; 	.DB	"GAMESIZE: ", 0
; 	LD	HL, (GAMESIZ)
; 	CALL	PRTHEX_HL

; 	CALL	PRTSTRD
; 	.DB	CR, LF, "STORE(2): ", 0
; 	LD	HL, STORE + $5000
; 	CALL	PRTHEX_HL

; 	CALL	PRTSTRD
; 	.DB	CR, LF, "game-loc(2): ", 0

; 	LD	HL, $5000	; DEST AT $8000+GAMESIZ-1
; 	LD	BC, (GAMELOC)
; 	ADD	HL, BC
; 	CALL	PRTHEX_HL
; 	CALL	PRTSTRD
; 	.DB	CR, LF, 0

; ;TMS_USRDATREG	.EQU	$BE
; TMS_CMDREG	.EQU	$BF		; READ STATUS / WRITE REG SEL

; TMSCTRL1:       .EQU   1               ; CONTROL BITS

; 	; ENSURE TMS IS NOT THROWING INTERRUPTS
; 	; SO WHEN NMI IS SELECTED NO INTERRUPTS WILL BE RAISED
; 	; UNTIL BIOS IS LOADED
; 	LD	A, $50
; 	OUT	(TMS_CMDREG),A		; WRITE IT
; 	EX (SP),HL	; WAIT
; 	EX (SP),HL
; 	LD	A,$81	; SET THE DESIRED REGISTER
; 	OUT	(TMS_CMDREG),A		; SELECT THE DESIRED REGISTER

; 	DI

; 	; SHIFT BIOS FROM $0100 TO 0000
; 	LD	HL, $0100
; 	LD	DE, $0000
; 	LD	BC, $2000		; BIOS SIZE
; 	LDIR

; 	; SHIFT GAME ROM FROM STORE TO UPPER MEM
; 	LD	BC, (GAMESIZ)

; 	LD	HL, $8000	; DEST AT $8000+GAMESIZ-1
; 	ADD	HL, BC
; 	DEC	HL
; 	EX	DE, HL

; 	LD	HL, STORE	; SOURCE AT STORE+GAMESIZ-1
; 	ADD	HL, BC
; 	DEC	HL

; 	LDDR			; SHIFT TO UPPER RAM

; 	; COPY ROM DATA TO $10000-SIZE TO UPPER RAM (CLOBBER HBIOS)

; 	; !HBIOS NOT USABLE NOW!
; 	; MOVE BIOS TO 0000
; 	; SET CLOCK TO 1/2 SPEED
; 	; JP	0

; ; 	;LOAD FIRST 256 BYTES FROM EXTERNAL ROM?
; ; 	ld	e,BID_ROMEX			;  FIRST PAGE IN EXTERNAL ROM
; ; 	ld	d,BID_USR		; dest is user bank
; ; 	ld	hl,256		; HL := image size
; ; 	ld	b,BF_SYSSETCPY		; HBIOS func: setup bank copy
; ; 	rst	08			; do it

; ; 	ld	de,STORE		; DE := run dest adr
; ; 	ld	hl,0		; HL := image source adr
; ; 	ld	b,BF_SYSBNKCPY		; HBIOS func: bank copy
; ; 	rst	08



; skip1:
; 	INC	HL
; 	DJNZ	LOOP2

; ; 	LD	A, $FF		; DROP CLOCK TO 3.6864
; ; 	OUT	(15), A

; ; 	LD	A, $FF
; ; 	OUT	(14), A		; SWITCH TO NMI

; ; 	JP	0	;


NOROM:
	CALL	PRTSTRD
	.DB	"NO ROM FOUND", CR, LF, 0


	JP	0

	; dump the 256 bytes at HL
dumpdat:

	;LD	HL, STORE	; SOURCE AT STORE+GAMESIZ-1

	LD	B, 0
	ld	c, 16

LOOP2:
	LD	A, (HL)
	CALL	PRTHEX

	CALL	PRTSTRD
	.DB	" ", 0

	dec	c
	jr	nz, skip1

	ld	c, 16
	call	CRLF

skip1:
	INC	HL
	DJNZ	LOOP2
	RET
;
; OUTPUT CHARACTER IN A TO CONSOLE DEVICE
;
COUT:	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	AF
	LD	BC,BF_CIOOUT << 8
	LD	E,A
	RST	08
	POP	AF
	POP	HL
	POP	DE
	POP	BC
	RET
;
; OUTPUT CHARACTER IN A TO CONSOLE DEVICE
;
COUTE:	PUSH	AF
	LD	A,E
	CALL	COUT
	POP	AF
	RET
;
; WAIT FOR A CHARACTER FROM THE CONSOLE DEVICE AND RETURN IT IN A
;
CIN:	PUSH	BC
	LD	B,00H
	LD	C,00H
	RST	08
	LD	A,E
	POP	BC
	RET

;===============================================================================
; PRINT CHARACTER IN A WITHOUT DESTROYING ANY REGISTERS

;===============================================================================
; PRINT A STRING DIRECT: REFERENCED BY POINTER AT TOP OF STACK
; STRING MUST BE TERMINATED BY '$'
; USAGE:
;   CALL PRTSTR
;   .DB  "HELLO$"

PRTSTRD:
	EX	(SP), HL
	push	af
	CALL	PRTSTRZ
	pop	af
	EX	(SP), HL
	RET


;===============================================================================
; PRINT A $ TERMINATED STRING AT (HL) WITHOUT DESTROYING ANY REGISTERS
PRTSTRZ:
	LD	A, (HL)			; GET NEXT CHAR
	INC	HL
	CP	0
	RET	Z
	CALL	COUT
	JR	PRTSTRZ

PRTSTRDE:
	PUSH	HL
	PUSH	DE
	EX	DE, HL
	CALL	PRTSTRZ
	POP	DE
	POP	HL
	RET

PRTHEX_DE:
	PUSH	HL
	EX	DE, HL
	CALL	PRTHEX_HL
	POP	HL
	RET

PRTHEX_HL:
	LD	A, H
	CALL	PRTHEX
	LD	A, L
	CALL	PRTHEX
	RET
;===============================================================================
; PRINT THE VALUE IN A IN HEX WITHOUT DESTROYING ANY REGISTERS

PRTHEX:
	PUSH	AF			; SAVE AF
	PUSH	DE			; SAVE DE
	CALL	HEXASCII		; CONVERT VALUE IN A TO HEX CHARS IN DE
	LD	A, D			; GET THE HIGH ORDER HEX CHAR
	CALL	COUT			; PRINT IT
	LD	A, E			; GET THE LOW ORDER HEX CHAR
	CALL	COUT			; PRINT IT
	POP	DE			; RESTORE DE
	POP	AF			; RESTORE AF
	RET				; DONE

;===============================================================================
; CONVERT BINARY VALUE IN A TO ASCII HEX CHARACTERS IN DE

HEXASCII:
	LD	D, A			; SAVE A IN D
	CALL	HEXCONV			; CONVERT LOW NIBBLE OF A TO HEX
	LD	E, A			; SAVE IT IN E
	LD	A, D			; GET ORIGINAL VALUE BACK
	RLCA				; ROTATE HIGH ORDER NIBBLE TO LOW BITS
	RLCA
	RLCA
	RLCA
	CALL	HEXCONV			; CONVERT NIBBLE
	LD	D, A			; SAVE IT IN D
	RET				; DONE

;===============================================================================
; CONVERT LOW NIBBLE OF A TO ASCII HEX

HEXCONV:
	AND	$0F	     		; LOW NIBBLE ONLY
	ADD	A, $90
	DAA
	ADC	A, $40
	DAA
	RET

;===============================================================================
; START A NEW LINE

CRLF:
	LD	A, 13			; <CR>
	CALL	COUT			; PRINT IT
	LD	A, 10			; <LF>
	JR	COUT			; PRINT IT

; GAMELOC:
; 	DEFW	0
; GAMESIZ:
; 	DEFW	0

STORE:	.DS	256, 0

; 	.dephase

; APPSIZE:	.equ	$-APPLOC

	.END
